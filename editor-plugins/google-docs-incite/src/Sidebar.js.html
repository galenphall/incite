<script>
  // ── State ──────────────────────────────────────────────────

  var state = {
    loading: false,
    results: [],
    timing: null,
    error: null,
    settings: null,  // loaded from server on init
    serverInfo: null, // from /health
    googleToken: null,
    googleTokenFetchedAt: 0,
    trackedCitations: [],
    bibExpanded: true,
    queryText: null,  // last query text for context display
    collections: [],  // available collections (cloud mode only)
    collectionId: null // selected collection ID for filtering
  };

  // ── Init ───────────────────────────────────────────────────

  document.addEventListener('DOMContentLoaded', function() {
    // Disable button until bridge + server are confirmed ready
    var btn = document.getElementById('btn-refresh');
    btn.disabled = true;
    btn.textContent = 'Connecting…';

    loadSettings(function() {
      // Pre-fetch Google token for cloud mode before first health check
      var ready = function() {
        checkServer(function() {
          btn.disabled = false;
          btn.textContent = 'Get Recommendations';
        });
      };
      if (state.settings.apiMode === 'cloud' && !state.settings.apiToken) {
        getGoogleTokenCached().then(ready).catch(ready);
      } else {
        ready();
      }
    });

    // Load tracked citations from document properties
    google.script.run
      .withSuccessHandler(function(citations) {
        state.trackedCitations = citations || [];
        renderBibliography();
      })
      .withFailureHandler(function() {
        state.trackedCitations = [];
      })
      .getCitations();

    // Re-check server health every 30s so status updates if server comes online
    // Skip health checks while a recommendation request is in flight to avoid
    // saturating the browser's per-origin connection pool in the sandbox.
    setInterval(function() {
      if (!state.loading) checkServer();
    }, 30000);

    btn.addEventListener('click', onRefresh);
    document.getElementById('btn-settings').addEventListener('click', onOpenSettings);

    // Collection filter dropdown
    document.getElementById('collection-select').addEventListener('change', function() {
      state.collectionId = this.value || null;
    });

    // Listen for Chrome extension hotkey trigger
    window.addEventListener('message', function(event) {
      if (event.data && event.data.type === 'INCITE_TRIGGER') {
        onRefresh();
      }
    });
  });

  // ── Permission error detection ──────────────────────────────

  /** Check if an Apps Script error is a multi-account PERMISSION_DENIED issue. */
  function isMultiAccountError(err) {
    if (!err || !err.message) return false;
    var msg = err.message.toLowerCase();
    return msg.indexOf('permission_denied') !== -1
      || msg.indexOf('warden') !== -1
      || msg.indexOf('transporterror') !== -1;
  }

  function loadSettings(callback) {
    google.script.run
      .withSuccessHandler(function(settings) {
        state.settings = settings;
        if (callback) callback();
      })
      .withFailureHandler(function(err) {
        if (isMultiAccountError(err)) {
          showError(
            'Multiple Google accounts detected. google.script.run cannot resolve ' +
            'the correct account. Try using an Incognito window with a single account.'
          );
        }
        state.settings = {
          apiMode: 'cloud',
          cloudUrl: 'https://inciteref.com',
          apiUrl: 'http://127.0.0.1:8230',
          apiToken: '',
          k: 10,
          authorBoost: 1.0,
          contextSentences: 6,
          insertFormat: '({first_author}, {year})',
          showParagraphs: true
        };
        if (callback) callback();
      })
      .getSettings();
  }

  // ── API helpers ───────────────────────────────────────────

  /** Return the base URL for the current API mode. */
  function getBaseUrl() {
    if (state.settings.apiMode === 'cloud') {
      return (state.settings.cloudUrl || 'https://inciteref.com').replace(/\/+$/, '');
    }
    return (state.settings.apiUrl || 'http://127.0.0.1:8230').replace(/\/+$/, '');
  }

  /** Return the recommend endpoint path for the current API mode. */
  function getRecommendPath() {
    return state.settings.apiMode === 'cloud' ? '/api/v1/recommend' : '/recommend';
  }

  /** Return auth headers (sync, only for manual mc_ tokens or local mode). */
  function getAuthHeaders() {
    var headers = { 'Content-Type': 'application/json' };
    if (state.settings.apiMode === 'cloud' && state.settings.apiToken) {
      headers['Authorization'] = 'Bearer ' + state.settings.apiToken;
    }
    return headers;
  }

  var GOOGLE_TOKEN_MAX_AGE_MS = 45 * 60 * 1000; // 45 minutes

  /** Get a cached Google OAuth token, refreshing if expired. Returns a Promise. */
  function getGoogleTokenCached() {
    var now = Date.now();
    if (state.googleToken && (now - state.googleTokenFetchedAt) < GOOGLE_TOKEN_MAX_AGE_MS) {
      return Promise.resolve(state.googleToken);
    }
    return new Promise(function(resolve, reject) {
      google.script.run
        .withSuccessHandler(function(token) {
          state.googleToken = token;
          state.googleTokenFetchedAt = Date.now();
          resolve(token);
        })
        .withFailureHandler(function(err) {
          if (isMultiAccountError(err)) {
            reject(new Error(
              'Multiple Google accounts detected. google.script.run cannot resolve ' +
              'the correct account. Try using an Incognito window with a single account.'
            ));
          } else {
            reject(err);
          }
        })
        .getGoogleToken();
    });
  }

  /** Return auth headers for the current API mode (async — uses Google token when no manual token). */
  function getAuthHeadersAsync() {
    var headers = { 'Content-Type': 'application/json' };
    if (state.settings.apiMode !== 'cloud') {
      return Promise.resolve(headers);
    }
    // Manual mc_ token takes priority
    if (state.settings.apiToken) {
      headers['Authorization'] = 'Bearer ' + state.settings.apiToken;
      return Promise.resolve(headers);
    }
    // Otherwise use Google OAuth token
    return getGoogleTokenCached().then(function(token) {
      headers['Authorization'] = 'Bearer ' + token;
      return headers;
    });
  }

  /**
   * Fetch wrapper that attaches auth headers and retries once on 401
   * (clears cached Google token and re-fetches).
   */
  function fetchWithAuth(url, options, timeoutMs) {
    options = options || {};
    return getAuthHeadersAsync().then(function(headers) {
      var opts = Object.assign({}, options, {
        headers: Object.assign({}, options.headers || {}, headers)
      });
      return fetchWithTimeout(url, opts, timeoutMs);
    }).then(function(resp) {
      // On 401 with Google token, clear cache and retry once
      if (resp.status === 401 && state.settings.apiMode === 'cloud'
          && !state.settings.apiToken && state.googleToken) {
        state.googleToken = null;
        state.googleTokenFetchedAt = 0;
        return getAuthHeadersAsync().then(function(headers) {
          var opts = Object.assign({}, options, {
            headers: Object.assign({}, options.headers || {}, headers)
          });
          return fetchWithTimeout(url, opts, timeoutMs);
        });
      }
      return resp;
    });
  }

  // ── Server health check ────────────────────────────────────

  function checkServer(callback) {
    var base = getBaseUrl();
    var healthPath = state.settings.apiMode === 'cloud' ? '/api/v1/health' : '/health';
    var url = base + healthPath;
    fetchWithAuth(url, {}, 5000)
      .then(function(resp) { return resp.json(); })
      .then(function(data) {
        state.serverInfo = data;
        var label = state.settings.apiMode === 'cloud' ? 'Cloud' : 'Local';
        // Cloud returns {status: "ready"|"processing"|"no_library", corpus_size}
        // Local returns {status: "healthy"|"unhealthy", ready?: bool}
        var isReady = data.status === 'ready' || data.status === 'healthy' || data.ready;
        if (isReady) {
          var size = data.corpus_size != null ? ' (' + data.corpus_size + ' papers)' : '';
          showServerStatus('connected', label + size);
          // Fetch collections in cloud mode
          if (state.settings.apiMode === 'cloud') {
            fetchCollections();
          }
        } else if (data.status === 'no_library') {
          showServerStatus('loading', 'No library found — upload papers at inciteref.com');
        } else {
          showServerStatus('loading', 'Library is processing…');
        }
        if (callback) callback(isReady);
      })
      .catch(function(err) {
        if (state.settings.apiMode === 'cloud') {
          showServerStatus('offline', 'Cannot reach cloud — check connection or Settings');
        } else if (err && err.name === 'AbortError') {
          showServerStatus('offline', 'Server not responding — run: incite serve');
        } else {
          showServerStatus('offline', 'Server not running — run: incite serve');
        }
        if (callback) callback(false);
      });
  }

  /** Show server health indicator: update dot color + status bar text. */
  function showServerStatus(level, message) {
    // Update status dot
    var dot = document.getElementById('status-dot');
    dot.className = 'mc-status-dot ' + level;
    dot.title = message;

    // Update text status bar
    var bar = document.getElementById('status-bar');
    bar.textContent = message;
    bar.className = 'mc-status visible mc-server-' + level;
  }

  // ── Collections ──────────────────────────────────────────────

  function fetchCollections() {
    var base = getBaseUrl();
    fetchWithAuth(base + '/api/v1/library/collections', {}, 5000)
      .then(function(resp) { return resp.json(); })
      .then(function(data) {
        state.collections = data.collections || [];
        renderCollectionDropdown();
      })
      .catch(function() {
        // Silently ignore — collections are optional
      });
  }

  function renderCollectionDropdown() {
    var filterEl = document.getElementById('collection-filter');
    var selectEl = document.getElementById('collection-select');
    if (!filterEl || !selectEl) return;

    if (state.settings.apiMode !== 'cloud' || state.collections.length === 0) {
      filterEl.style.display = 'none';
      return;
    }

    // Rebuild options
    selectEl.innerHTML = '<option value="">All papers</option>';
    for (var i = 0; i < state.collections.length; i++) {
      var c = state.collections[i];
      var opt = document.createElement('option');
      opt.value = String(c.id);
      opt.textContent = c.name + ' (' + c.item_count + ')';
      if (state.collectionId === String(c.id)) {
        opt.selected = true;
      }
      selectEl.appendChild(opt);
    }
    filterEl.style.display = '';
  }

  // ── Get recommendations ────────────────────────────────────

  function onRefresh() {
    if (state.loading) return;
    setLoading(true);

    // Timeout guard: if google.script.run hangs (cold start, auth issue),
    // reset after 15s so the sidebar isn't stuck on "Searching..." forever.
    var timedOut = false;
    var timeout = setTimeout(function() {
      timedOut = true;
      showError('Timed out reading document. Click in your doc and try again.');
      setLoading(false);
    }, 15000);

    // Step 1: get context from the document via Apps Script
    google.script.run
      .withSuccessHandler(function(context) {
        clearTimeout(timeout);
        if (timedOut) return;
        if (context.error) {
          showError(context.error);
          setLoading(false);
          return;
        }
        // Step 2: call local inCite API
        fetchRecommendations(context);
      })
      .withFailureHandler(function(err) {
        clearTimeout(timeout);
        if (timedOut) return;
        if (isMultiAccountError(err)) {
          showError(
            'Multiple Google accounts detected. google.script.run cannot resolve ' +
            'the correct account. Try using an Incognito window with a single account.'
          );
        } else {
          showError('Could not read document: ' + err.message);
        }
        setLoading(false);
      })
      .getContextAtCursor();
  }

  /** Wrapper around fetch() that aborts after timeoutMs milliseconds. */
  function fetchWithTimeout(url, options, timeoutMs) {
    var controller = new AbortController();
    var opts = Object.assign({}, options, { signal: controller.signal });
    var timer = setTimeout(function() { controller.abort(); }, timeoutMs);
    return fetch(url, opts).finally(function() { clearTimeout(timer); });
  }

  function fetchRecommendations(context) {
    state.queryText = context.text;
    var url = getBaseUrl() + getRecommendPath();
    var body = {
      query: context.text,
      k: state.settings.k,
      author_boost: state.settings.authorBoost
    };
    if (context.cursorSentenceIndex !== undefined) {
      body.cursor_sentence_index = context.cursorSentenceIndex;
    }
    if (state.collectionId) {
      body.collection_id = state.collectionId;
    }

    fetchWithAuth(url, {
      method: 'POST',
      body: JSON.stringify(body)
    }, 30000)
    .then(function(resp) {
      if (!resp.ok) throw new Error('Server returned ' + resp.status);
      return resp.json();
    })
    .then(function(data) {
      state.results = data.recommendations || [];
      state.timing = data.timing || null;
      state.error = null;
      setLoading(false);
      renderResults();
    })
    .catch(function(err) {
      var base = getBaseUrl();
      if (err && err.name === 'AbortError') {
        if (state.settings.apiMode === 'cloud') {
          showError('Request timed out reaching ' + base + '. Check your connection.');
        } else {
          showError('Request timed out. Is the inCite server running? Start with: incite serve');
        }
      } else {
        if (state.settings.apiMode === 'cloud') {
          showError('Could not reach cloud at ' + base + '. Check connection or Settings. (' + err.message + ')');
        } else {
          showError('Could not reach inCite server at ' + base + '. Is "incite serve" running? (' + err.message + ')');
        }
      }
      setLoading(false);
    });
  }

  // ── Insert citation ────────────────────────────────────────

  function onInsert(rec) {
    var firstAuthor = 'Unknown';
    if (rec.authors && rec.authors.length > 0) {
      var parts = rec.authors[0].trim().split(/\s+/);
      firstAuthor = parts[parts.length - 1];
      if (rec.authors.length > 1) {
        firstAuthor += ' et al.';
      }
    }

    var citation = state.settings.insertFormat
      .replace('{first_author}', firstAuthor)
      .replace('{year}', rec.year || 'n.d.')
      .replace('{paper_id}', rec.paper_id || '')
      .replace('{bibtex_key}', rec.bibtex_key || rec.paper_id || '')
      .replace('{title}', rec.title || '');

    google.script.run
      .withSuccessHandler(function() {
        // Brief visual feedback
        showStatus('Inserted: ' + citation);
        setTimeout(function() { showStatus(''); }, 2000);
        // Track citation and update bibliography
        addTrackedCitation(rec);
        renderBibliography();
        updateCitedBadges();
      })
      .withFailureHandler(function(err) {
        if (isMultiAccountError(err)) {
          showError(
            'Multiple Google accounts detected. google.script.run cannot resolve ' +
            'the correct account. Try using an Incognito window with a single account.'
          );
        } else {
          showError('Could not insert citation: ' + err.message);
        }
      })
      .insertCitation(citation, rec);
  }

  /** Add a citation to local state (dedup by paper_id). */
  function addTrackedCitation(rec) {
    for (var i = 0; i < state.trackedCitations.length; i++) {
      if (state.trackedCitations[i].paper_id === rec.paper_id) return;
    }
    state.trackedCitations.push({
      paper_id: rec.paper_id,
      bibtex_key: rec.bibtex_key || rec.paper_id,
      title: rec.title,
      authors: rec.authors || [],
      year: rec.year,
      doi: rec.doi,
      journal: rec.journal,
      insertedAt: Date.now()
    });
  }

  // ── Settings ───────────────────────────────────────────────

  function onOpenSettings() {
    google.script.run.showSettings();
  }

  // ── Rendering ──────────────────────────────────────────────

  function setLoading(on) {
    state.loading = on;
    var btn = document.getElementById('btn-refresh');
    btn.disabled = on;
    btn.textContent = on ? 'Searching…' : 'Get Recommendations';

    if (on) {
      var container = document.getElementById('results-container');
      container.innerHTML =
        '<div class="mc-state">' +
          '<div class="mc-spinner"></div>' +
          '<div>Searching for citations…</div>' +
        '</div>';
    }
  }

  function showError(message) {
    state.error = message;
    state.results = [];
    var container = document.getElementById('results-container');
    container.innerHTML = '<div class="mc-error">' + escapeHtml(message) + '</div>';
    document.getElementById('timing-bar').style.display = 'none';
  }

  function showStatus(message) {
    var bar = document.getElementById('status-bar');
    if (message) {
      bar.textContent = message;
      bar.className = 'mc-status visible';
    } else {
      bar.className = 'mc-status';
    }
  }

  /** Map confidence score to human-readable label. */
  function confidenceLabel(score) {
    if (score >= 0.55) return 'Strong';
    if (score >= 0.35) return 'Good';
    return 'Weak';
  }

  function renderResults() {
    var container = document.getElementById('results-container');
    container.innerHTML = '';

    if (state.results.length === 0) {
      container.innerHTML =
        '<div class="mc-state">' +
          '<div class="mc-state-icon">&#x1F50D;</div>' +
          '<div>No results. Try placing your cursor in a paragraph with more context.</div>' +
        '</div>';
      document.getElementById('timing-bar').style.display = 'none';
      return;
    }

    // Query context bar — show what text the recommendations are based on
    if (state.queryText) {
      var queryBar = document.createElement('div');
      queryBar.className = 'mc-query-context';
      var truncated = state.queryText.length > 80
        ? state.queryText.slice(0, 80) + '…'
        : state.queryText;
      queryBar.innerHTML = '<strong>Query:</strong> ' + escapeHtml(truncated);
      queryBar.title = state.queryText;
      container.appendChild(queryBar);
    }

    var showParagraphs = state.settings.showParagraphs;

    for (var i = 0; i < state.results.length; i++) {
      var rec = state.results[i];
      var card = document.createElement('div');
      card.className = 'mc-result';

      // Header: rank + confidence label
      var header = document.createElement('div');
      header.className = 'mc-result-header';

      var rank = document.createElement('span');
      rank.className = 'mc-rank';
      rank.textContent = rec.rank + '.';
      header.appendChild(rank);

      var conf = rec.confidence || 0;
      var confBadge = document.createElement('span');
      confBadge.className = 'mc-confidence ' +
        (conf >= 0.55 ? 'mc-confidence-high' :
         conf >= 0.35 ? 'mc-confidence-mid' : 'mc-confidence-low');
      confBadge.textContent = confidenceLabel(conf);
      confBadge.title = 'Score: ' + conf.toFixed(3);
      header.appendChild(confBadge);

      card.appendChild(header);

      // Title
      var title = document.createElement('div');
      title.className = 'mc-title';
      title.textContent = rec.title || 'Untitled';
      card.appendChild(title);

      // Authors + year
      if (rec.authors || rec.year) {
        var meta = document.createElement('div');
        meta.className = 'mc-meta';
        var metaParts = [];
        if (rec.authors && rec.authors.length > 0) {
          var names = rec.authors.slice(0, 3).join(', ');
          if (rec.authors.length > 3) names += ' et al.';
          metaParts.push(names);
        }
        if (rec.year) metaParts.push('(' + rec.year + ')');
        meta.textContent = metaParts.join(' ');
        card.appendChild(meta);
      }

      // Collapsible evidence snippets
      if (showParagraphs) {
        var hasEvidence = (rec.matched_paragraphs && rec.matched_paragraphs.length) || rec.matched_paragraph;
        if (hasEvidence) {
          // Toggle button
          var toggleBtn = document.createElement('button');
          toggleBtn.className = 'mc-evidence-toggle';
          toggleBtn.textContent = 'Show evidence \u25BE';
          card.appendChild(toggleBtn);

          // Evidence container (collapsed by default)
          var evidenceWrap = document.createElement('div');
          evidenceWrap.className = 'mc-evidence-content';

          if (rec.matched_paragraphs && rec.matched_paragraphs.length) {
            rec.matched_paragraphs.forEach(function(snippet, idx) {
              var para = document.createElement('div');
              para.className = idx === 0 ? 'mc-paragraph' : 'mc-paragraph mc-paragraph-secondary';
              if (snippet.score != null) {
                var badge = document.createElement('span');
                badge.className = 'mc-evidence-score';
                badge.textContent = Math.round(snippet.score * 100) + '%';
                para.appendChild(badge);
              }
              renderHighlightedText(snippet.text, para, 350);
              evidenceWrap.appendChild(para);
            });
          } else if (rec.matched_paragraph) {
            var para = document.createElement('div');
            para.className = 'mc-paragraph';
            renderHighlightedText(rec.matched_paragraph, para, 350);
            evidenceWrap.appendChild(para);
          }

          card.appendChild(evidenceWrap);

          // Wire up toggle
          (function(btn, wrap) {
            btn.addEventListener('click', function() {
              var expanded = wrap.classList.toggle('expanded');
              btn.textContent = expanded ? 'Hide evidence \u25B4' : 'Show evidence \u25BE';
            });
          })(toggleBtn, evidenceWrap);
        }
      }

      // Insert button
      var actions = document.createElement('div');
      actions.className = 'mc-actions';
      var btn = document.createElement('button');
      btn.className = 'mc-insert-btn';
      btn.textContent = '+ Insert';
      btn.setAttribute('data-index', i);
      btn.addEventListener('click', (function(r) {
        return function() { onInsert(r); };
      })(rec));
      actions.appendChild(btn);
      card.appendChild(actions);

      container.appendChild(card);
    }

    // Timing footer
    if (state.timing) {
      var timingBar = document.getElementById('timing-bar');
      timingBar.textContent = state.timing.total_ms + ' ms';
      timingBar.style.display = 'block';
    }

    // Show "Cited" badges on already-tracked papers
    updateCitedBadges();
  }

  /**
   * Render text with **bold** markers converted to <strong> elements.
   * Truncates around the highlighted portion. Ported from Obsidian plugin.
   */
  function renderHighlightedText(text, container, maxLength) {
    var startBold = text.indexOf('**');
    var endBold = text.indexOf('**', startBold + 2);

    // No valid highlight — just truncate
    if (startBold === -1 || endBold === -1) {
      var truncated = text.length > maxLength;
      container.textContent = truncated ? text.slice(0, maxLength) + '…' : text;
      return;
    }

    // Window around the highlight
    var highlightEnd = endBold + 2;
    var highlightLength = highlightEnd - startBold;
    var available = maxLength - highlightLength;
    var ctxBefore = Math.floor(available * 0.3);
    var ctxAfter = available - ctxBefore;

    var sliceStart = Math.max(0, startBold - ctxBefore);
    var sliceEnd = Math.min(text.length, highlightEnd + ctxAfter);
    var display = text.slice(sliceStart, sliceEnd);

    var prefixEllipsis = sliceStart > 0;
    var suffixEllipsis = sliceEnd < text.length;

    if (prefixEllipsis) {
      var spaceIdx = display.indexOf(' ');
      if (spaceIdx > 0 && spaceIdx < 20) {
        display = display.slice(spaceIdx + 1);
      }
      display = '…' + display;
    }
    if (suffixEllipsis) {
      display = display + '…';
    }

    // Split on **text** and render
    var parts = display.split(/(\*\*.+?\*\*)/g);
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.indexOf('**') === 0 && part.lastIndexOf('**') === part.length - 2) {
        var strong = document.createElement('strong');
        strong.textContent = part.slice(2, -2);
        container.appendChild(strong);
      } else if (part) {
        container.appendChild(document.createTextNode(part));
      }
    }
  }

  function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
  }

  // ── Bibliography ──────────────────────────────────────────────

  /** Render the bibliography section below results. */
  function renderBibliography() {
    var section = document.getElementById('bibliography-section');
    if (!section) return;
    section.innerHTML = '';

    var count = state.trackedCitations.length;
    if (count === 0) return;

    // Collapsible header
    var header = document.createElement('div');
    header.className = 'mc-bib-header';
    header.addEventListener('click', function() {
      state.bibExpanded = !state.bibExpanded;
      renderBibliography();
    });

    var label = document.createElement('span');
    label.className = 'mc-bib-header-label';
    label.textContent = 'Bibliography (' + count + ' citation' + (count !== 1 ? 's' : '') + ')';
    header.appendChild(label);

    var toggle = document.createElement('span');
    toggle.className = 'mc-bib-toggle' + (state.bibExpanded ? ' expanded' : '');
    toggle.textContent = '\u25B6';
    header.appendChild(toggle);

    section.appendChild(header);

    if (!state.bibExpanded) return;

    // Body
    var body = document.createElement('div');
    body.className = 'mc-bib-body';

    // Export buttons
    var exportRow = document.createElement('div');
    exportRow.className = 'mc-bib-export';

    var btnBibtex = document.createElement('button');
    btnBibtex.className = 'mc-copy-btn';
    btnBibtex.textContent = 'Copy BibTeX';
    btnBibtex.addEventListener('click', function() {
      copyToClipboard(formatBibTeX(state.trackedCitations), btnBibtex);
    });
    exportRow.appendChild(btnBibtex);

    var btnRis = document.createElement('button');
    btnRis.className = 'mc-copy-btn';
    btnRis.textContent = 'Copy RIS';
    btnRis.addEventListener('click', function() {
      copyToClipboard(formatRIS(state.trackedCitations), btnRis);
    });
    exportRow.appendChild(btnRis);

    var btnApa = document.createElement('button');
    btnApa.className = 'mc-copy-btn';
    btnApa.textContent = 'Copy APA';
    btnApa.addEventListener('click', function() {
      copyToClipboard(formatAPA(state.trackedCitations), btnApa);
    });
    exportRow.appendChild(btnApa);

    var btnInsert = document.createElement('button');
    btnInsert.className = 'mc-copy-btn';
    btnInsert.textContent = 'Insert';
    btnInsert.addEventListener('click', function() {
      var text = formatAPA(state.trackedCitations);
      google.script.run
        .withSuccessHandler(function() {
          btnInsert.textContent = 'Inserted!';
          setTimeout(function() { btnInsert.textContent = 'Insert'; }, 1500);
        })
        .withFailureHandler(function(err) {
          if (isMultiAccountError(err)) {
            showError(
              'Multiple Google accounts detected. google.script.run cannot resolve ' +
              'the correct account. Try using an Incognito window with a single account.'
            );
          } else {
            showError('Could not insert bibliography: ' + err.message);
          }
        })
        .insertBibliography(text);
    });
    exportRow.appendChild(btnInsert);

    body.appendChild(exportRow);

    // Citation entries
    for (var i = 0; i < state.trackedCitations.length; i++) {
      var cit = state.trackedCitations[i];
      var entry = document.createElement('div');
      entry.className = 'mc-bib-entry';

      var textDiv = document.createElement('div');
      textDiv.className = 'mc-bib-entry-text';

      var titleSpan = document.createElement('div');
      titleSpan.className = 'mc-bib-entry-title';
      titleSpan.textContent = cit.title || 'Untitled';
      textDiv.appendChild(titleSpan);

      var metaParts = [];
      if (cit.authors && cit.authors.length > 0) {
        var names = cit.authors.slice(0, 3).join(', ');
        if (cit.authors.length > 3) names += ' et al.';
        metaParts.push(names);
      }
      if (cit.year) metaParts.push('(' + cit.year + ')');
      if (metaParts.length > 0) {
        var metaSpan = document.createElement('div');
        metaSpan.className = 'mc-bib-entry-meta';
        metaSpan.textContent = metaParts.join(' ');
        textDiv.appendChild(metaSpan);
      }

      entry.appendChild(textDiv);

      var removeBtn = document.createElement('button');
      removeBtn.className = 'mc-remove-btn';
      removeBtn.textContent = 'Remove';
      removeBtn.setAttribute('data-paper-id', cit.paper_id);
      removeBtn.addEventListener('click', (function(paperId) {
        return function() { onRemoveCitation(paperId); };
      })(cit.paper_id));
      entry.appendChild(removeBtn);

      body.appendChild(entry);
    }

    section.appendChild(body);
  }

  /** Remove a citation from tracking. */
  function onRemoveCitation(paperId) {
    google.script.run
      .withSuccessHandler(function(citations) {
        state.trackedCitations = citations || [];
        renderBibliography();
        updateCitedBadges();
      })
      .withFailureHandler(function() {
        // Remove locally even if server call fails
        state.trackedCitations = state.trackedCitations.filter(function(c) {
          return c.paper_id !== paperId;
        });
        renderBibliography();
        updateCitedBadges();
      })
      .removeCitation(paperId);
  }

  /** Update "Cited" badges on currently displayed result cards. */
  function updateCitedBadges() {
    var citedIds = {};
    for (var i = 0; i < state.trackedCitations.length; i++) {
      citedIds[state.trackedCitations[i].paper_id] = true;
    }
    // Remove existing badges
    var existing = document.querySelectorAll('.mc-cited-badge');
    for (var i = 0; i < existing.length; i++) {
      existing[i].parentNode.removeChild(existing[i]);
    }
    // Add badges to matching result cards
    var container = document.getElementById('results-container');
    var cards = container.querySelectorAll('.mc-result');
    for (var i = 0; i < cards.length; i++) {
      if (i < state.results.length && citedIds[state.results[i].paper_id]) {
        var headerEl = cards[i].querySelector('.mc-result-header');
        if (headerEl && !headerEl.querySelector('.mc-cited-badge')) {
          var badge = document.createElement('span');
          badge.className = 'mc-cited-badge';
          badge.textContent = 'Cited';
          headerEl.appendChild(badge);
        }
      }
    }
  }

  /** Copy text to clipboard and show brief feedback on button. */
  function copyToClipboard(text, btn) {
    navigator.clipboard.writeText(text).then(function() {
      var original = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(function() { btn.textContent = original; }, 1500);
    }).catch(function() {
      // Fallback for older browsers
      var ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      var original = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(function() { btn.textContent = original; }, 1500);
    });
  }

  // ── Export formatters ─────────────────────────────────────────

  function formatBibTeX(citations) {
    return citations.map(function(c) {
      var key = c.bibtex_key || c.paper_id || 'unknown';
      var authors = (c.authors || []).join(' and ');
      var lines = ['@article{' + key + ','];
      if (c.title) lines.push('  title = {' + c.title + '},');
      if (authors) lines.push('  author = {' + authors + '},');
      if (c.year) lines.push('  year = {' + c.year + '},');
      if (c.doi) lines.push('  doi = {' + c.doi + '},');
      if (c.journal) lines.push('  journal = {' + c.journal + '},');
      lines.push('}');
      return lines.join('\n');
    }).join('\n\n');
  }

  function formatRIS(citations) {
    return citations.map(function(c) {
      var lines = ['TY  - JOUR'];
      if (c.title) lines.push('TI  - ' + c.title);
      (c.authors || []).forEach(function(a) { lines.push('AU  - ' + a); });
      if (c.year) lines.push('PY  - ' + c.year);
      if (c.doi) lines.push('DO  - ' + c.doi);
      if (c.journal) lines.push('JO  - ' + c.journal);
      lines.push('ER  -');
      return lines.join('\n');
    }).join('\n\n');
  }

  function formatAPA(citations) {
    return citations.map(function(c) {
      var parts = [];
      // Authors
      if (c.authors && c.authors.length > 0) {
        var authorStrs = c.authors.map(function(name) {
          var nameParts = name.trim().split(/\s+/);
          if (nameParts.length < 2) return name;
          var last = nameParts[nameParts.length - 1];
          var initials = nameParts.slice(0, -1).map(function(n) {
            return n.charAt(0).toUpperCase() + '.';
          }).join(' ');
          return last + ', ' + initials;
        });
        if (authorStrs.length === 1) {
          parts.push(authorStrs[0]);
        } else if (authorStrs.length === 2) {
          parts.push(authorStrs[0] + ', & ' + authorStrs[1]);
        } else {
          parts.push(authorStrs.slice(0, -1).join(', ') + ', & ' + authorStrs[authorStrs.length - 1]);
        }
      }
      // Year
      parts.push('(' + (c.year || 'n.d.') + ').');
      // Title
      if (c.title) parts.push(c.title + '.');
      // Journal
      if (c.journal) parts.push(c.journal + '.');
      // DOI
      if (c.doi) parts.push('https://doi.org/' + c.doi);
      return parts.join(' ');
    }).join('\n\n');
  }
</script>
